
	//int novaPutanja = 0; //pomocna promijenljiva za cuvanje privremene najkrace putanje
	//dinamicka alokacija niza koji ce cuvati jednu vrstu matrice
	//int* ktaVrsta = (int*)malloc(sizeof(int) * n);
/*
	int korak = n / brojNiti;
	if (korak < 1) {
		printf("\nGreska: broj niti je veci od broja cvorova!\n");
	}
	*/

	//prvi pokusaj
	//promjenljiva k je privatna za svaku nit tj. svaka nit ima svoju kopiju nje
	//promjenljive matrica i ktiRed su zajednicke za sve niti

#pragma omp parallel num_threads(brojNiti) private (k) shared(matrica, ktaVrsta)
	for (k = 0; k < n; k++) {
		//naredna sekcija se izvrsava samo jednom od strane glavne niti (master thread)
#pragma omp master
		memcpy(ktaVrsta, matrica + (k * n), sizeof(int) * n); //kopira k-tu vrstu iz matrice u niz pomoću funkcije memcpy
		//petlja se dijeli izmedju niti, tako da svaka nit obradjuje dio iteracija
#pragma omp for private (i,j) schedule (static) //staticka raspodela iteracija znaci da svaka nit unapred dobija jednak broj iteracija
		for (i = 0; i < n; i++) {
			for (j = 0; j < n; j++) {
				novaPutanja = matrica[i * n + k] + ktaVrsta[j];
				//za svaki par cvorova i i j, izracunava se potencijalno nova kraca putanja koji prolazi kroz čvor k
				//ako je kraci od trenutnog najkraceg puta, vrijednost u matrici se azurira
				if (matrica[i * n + k] > novaPutanja)
					matrica[i * n + j] = novaPutanja;
			}

		}
	}